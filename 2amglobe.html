<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Globe - Clean</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:transparent}
    @font-face {
      font-family: 'Suisse';
      src: url('./css/suisse.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }
    body{
      font-family:'Suisse',"Courier New","Lucida Console",monospace;
      color:#CFCFCF; overflow:hidden;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    #stage{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;}
    #map{
      white-space:pre; line-height:1; letter-spacing:0; user-select:text;
      font-kerning:none; font-variant-ligatures:none; font-feature-settings:"liga" 0,"calt" 0;
      word-spacing:0;
    }
  </style>
</head>
<body>
  <div style="position: fixed; top: 10px; left: 10px; color: #CFCFCF; font-family: 'Suisse', monospace; font-size: 12px; z-index: 100;">
    <div>2am radio</div>
    <div id="currentLocation" style="color: #ff0088; margin-top: 5px;"></div>
  </div>
  <div id="stage">
    <div id="map" aria-label="Random ASCII globe"></div>
  </div>

  <script>
  const DEG = Math.PI/180;
  const rad = d=>d*DEG;
  const normLon = lon => ((lon + 180) % 360 + 360) % 360 - 180;

  function randomFloat(min, max) { return Math.random() * (max - min) + min; }
  function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function randomChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
  function randomHexColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }

  const OCEAN_CHARS = ['.', '~', '≈', '∼', '·', '○', '◦'];
  const COAST_CHARS = ['*', '#', '@', '&', '%', '▓', '█', '▪', '■'];
  const FILL_CHARS = ['=', '-', '+', '░', '▒', '▓', '█', ':', ';', '|'];
  const GRID_CHARS = ['.', ':', '+', '·', '×', '▫', '▪'];
  const LINE_CHARS = ['=', '-', '―', '━', '═', '▬'];

  const COLOR_SCHEMES = [
    { name: "Ocean Blue", ocean: "#1e3a5f", coast: "#d4af37", land1: "#228b22", land2: "#32cd32" },
    { name: "Desert", ocean: "#4682b4", coast: "#daa520", land1: "#deb887", land2: "#f4a460" },
    { name: "Arctic", ocean: "#191970", coast: "#87ceeb", land1: "#f0f8ff", land2: "#e0e0e0" },
    { name: "Tropical", ocean: "#006994", coast: "#ff7f50", land1: "#228b22", land2: "#90ee90" },
    { name: "Volcanic", ocean: "#2f4f4f", coast: "#ff4500", land1: "#8b4513", land2: "#a0522d" },
    { name: "Cyberpunk", ocean: "#0f0f23", coast: "#ff00ff", land1: "#00ffff", land2: "#ffff00" },
    { name: "Monochrome", ocean: "#333333", coast: "#cccccc", land1: "#666666", land2: "#999999" },
    { name: "Retro", ocean: "#000080", coast: "#ffa500", land1: "#800080", land2: "#ff69b4" }
  ];

  function generateRandomPalette() {
    const scheme = randomChoice(COLOR_SCHEMES);
    return {
      name: scheme.name,
      oceanChar: randomChoice(OCEAN_CHARS),
      coastChar: randomChoice(COAST_CHARS),
      fillAChar: randomChoice(FILL_CHARS),
      fillBChar: randomChoice(FILL_CHARS),
      gridChar: randomChoice(GRID_CHARS),
      equatorChar: randomChoice(LINE_CHARS),
      primeChar: randomChoice(LINE_CHARS),
      rimChar: randomChoice(['.', ':', '·', '○']),
      vignChar: randomChoice(['.', ':', '·', '▫']),
      colOcean: scheme.ocean,
      colCoast: scheme.coast,
      colFillA: scheme.land1,
      colFillB: scheme.land2,
      colGrid: randomHexColor(),
      colEquator: randomHexColor(),
      colPrime: randomHexColor(),
      colRim: randomHexColor(),
      colVign: randomHexColor(),
      col2AM: "#ff0088"
    };
  }

  function get2AMLongitude() {
    const now = new Date();
    const utc = now.getUTCHours() + now.getUTCMinutes()/60;
    let hoursFromUTC = 2 - utc; // longitude where local time is 02:00
    if (hoursFromUTC < -12) hoursFromUTC += 24;
    if (hoursFromUTC > 12)  hoursFromUTC -= 24;
    return normLon(hoursFromUTC * 15);
  }

  class RandomGlobe {
    constructor(){
      this.width = 100;
      this.height = 50;
      this.centerX = this.width/2;
      this.centerY = this.height/2;
      this.radius = 20;

      this.luminanceRamp = " .'`^\",:;Il!i><~+_-?][}{1)(|\\/*tfrxnvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
      this.host = document.getElementById("map");

      this.randomizeSettings();
      this.show2AM = true;
      this.initDetailedWorldData();
      this.recalcFontSize();
      this.bind();
      this.render();
      this.startLoop();
    }

    randomizeSettings() {
      this.longitude = randomFloat(-180, 180);
      this.centerLat = randomFloat(-30, 30);
      this.useLighting = Math.random() > 0.3;
      this.cellAR = 1.9;
      this.pal = generateRandomPalette();
      this.spinSpeed = 0.5;
    }

    bind(){
      window.addEventListener("resize", ()=>{
        this.recalcFontSize();
        this.render();
      });
    }

    measureCell(){
      const s=document.createElement("span");
      s.textContent="M";
      s.style.position="absolute"; s.style.visibility="hidden";
      s.style.fontFamily="'Courier New',monospace";
      s.style.lineHeight="1"; s.style.letterSpacing="0";
      document.body.appendChild(s);
      const r=s.getBoundingClientRect(); s.remove();
      return {cw:r.width, ch:r.height};
    }

    recalcFontSize(){
      const targetW = window.innerWidth - 20;
      const targetH = window.innerHeight - 20;
      let lo=6, hi=60, best=12;
      while(lo<=hi){
        const mid = Math.floor((lo+hi)/2);
        this.host.style.fontSize = mid+"px";
        const cell = this.measureCell();
        const ok = (this.width*cell.cw <= targetW) && (this.height*cell.ch <= targetH);
        if(ok){ best=mid; lo=mid+1; } else { hi=mid-1; }
      }
      this.host.style.fontSize = best+"px";
    }

    startLoop(){
      this.animationId = setInterval(()=>{
        this.longitude = (this.longitude + this.spinSpeed) % 360;
        this.render();
      }, 80);
    }

    initDetailedWorldData(){
      this.continents = {
        northAmerica: [[71,-156],[70,-140],[69,-133],[65,-135],[60,-135],[58,-94],[60,-64],[58,-62],[55,-57],[50,-56],[47,-58],[45,-60],[44,-67],[42,-68],[41,-70],[40,-72],[39,-74],[37,-75],[36,-76],[34,-78],[32,-81],[30,-81],[28,-82],[25,-80],[24,-81],[26,-82],[28,-84],[29,-85],[29,-87],[29,-90],[29,-94],[28,-95],[26,-97],[25,-98],[23,-106],[22,-105],[20,-105],[18,-103],[16,-95],[15,-93],[14,-92],[16,-87],[19,-96],[23,-110],[26,-112],[32,-117],[34,-118],[37,-122],[40,-124],[42,-124],[45,-124]],
        southAmerica: [[12,-71],[11,-68],[11,-60],[8,-58],[5,-51],[3,-48],[2,-44],[0,-42],[-3,-38],[-5,-36],[-8,-35],[-12,-37],[-16,-39],[-20,-40],[-23,-43],[-26,-48],[-30,-50],[-34,-52],[-38,-58],[-42,-62],[-46,-65],[-50,-67],[-55,-68],[-54,-70],[-52,-75],[-48,-74],[-40,-73],[-33,-71],[-25,-70],[-18,-70],[-10,-75],[-5,-78],[-1,-81],[1,-84],[3,-87],[5,-85],[8,-77],[10,-74]],
        europe: [[71,25],[70,28],[70,31],[68,30],[66,24],[64,20],[60,11],[58,8],[55,6],[51,3],[48,2],[45,-2],[43,-9],[41,-8],[38,-7],[36,-6],[38,-1],[40,0],[43,3],[45,5],[46,7],[47,12],[45,20],[46,25],[47,30],[48,35],[50,38],[52,40],[55,40],[58,38],[62,35],[65,32],[68,33]],
        africa: [[37,-6],[35,-5],[33,0],[32,10],[32,20],[32,32],[31,34],[28,38],[22,40],[15,42],[12,45],[12,51],[8,50],[0,45],[-5,42],[-12,40],[-18,38],[-22,35],[-26,33],[-30,28],[-33,25],[-35,20],[-34,18],[-33,18],[-28,15],[-20,12],[-15,12],[-8,8],[0,5],[5,3],[10,0],[15,-17],[18,-16],[21,-17],[25,-15],[30,-10],[35,-8]],
        asia: [[77,104],[75,120],[73,140],[70,160],[69,180],[66,-170],[62,-165],[60,-165],[58,-160],[55,-155],[50,140],[48,135],[45,132],[42,130],[38,128],[35,129],[32,125],[28,122],[24,121],[20,118],[18,109],[15,105],[10,103],[5,102],[1,104],[-5,110],[-8,115],[-6,120],[2,125],[8,120],[12,115],[15,105],[10,95],[8,77],[15,72],[20,70],[23,69],[28,70],[32,72],[37,75],[40,78],[42,80],[45,78],[50,75],[55,73],[60,70],[65,65],[68,50],[70,40],[68,33]],
        australia: [[-10,142],[-11,143],[-12,143],[-15,145],[-20,149],[-24,153],[-28,153],[-32,152],[-35,150],[-37,148],[-39,146],[-38,143],[-37,140],[-35,137],[-33,135],[-30,133],[-26,130],[-22,114],[-20,116],[-18,122],[-15,128],[-12,130],[-11,135],[-10,140]]
      };
    }

    render(){
      const W=this.width,H=this.height;
      const cx=this.centerX, cy=this.centerY;
      const ar = this.cellAR;
      this.radius = Math.floor(Math.min(W, H*ar)/2) - 3;
      const R=this.radius;

      const buf = Array.from({length:H},()=>Array(W).fill(' '));
      const typ = Array.from({length:H},()=>Array(W).fill('ocean'));

      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const dx = x - cx;
          const dy = y - cy;
          const dist = Math.hypot(dx, dy * ar);
          if(dist>R){ buf[y][x]=' '; typ[y][x]='void'; continue; }

          const edgeFactor = 1 - (dist/R);
          const edgeBlend = Math.pow(edgeFactor, 0.4);

          const sx = dx/R;
          const sy = -(dy * ar)/R;
          const z2 = 1 - sx*sx - sy*sy;
          if(z2<0){ buf[y][x]=' '; typ[y][x]='void'; continue; }
          const sz = Math.sqrt(z2);

          const lat = Math.asin(sy)*180/Math.PI + this.centerLat;
          const lon = normLon(Math.atan2(sx, sz)*180/Math.PI + this.longitude);

          const isLand = this.isPointOnLandEnhanced(lat, lon);
          typ[y][x] = isLand ? 'land' : 'ocean';

          let L;
          if(!isLand){
            L = 0.2 + 0.1 * Math.sin(lon*0.05);
          }else{
            L = 0.5 + 0.3 * Math.sin(lat*0.08)*Math.cos(lon*0.08);
          }

          if(this.useLighting){
            const lx=-0.4, ly=0.6, lz=0.7;
            const dot = sx*lx + sy*ly + sz*lz;
            const light = Math.max(0.3, Math.min(1.0, 0.5 + dot*0.5));
            L *= light;
          }

          L *= edgeBlend;
          buf[y][x] = this.lumToChar(L);
        }
      }

      // Mark coasts
      for(let y=1;y<H-1;y++){
        for(let x=1;x<W-1;x++){
          if(typ[y][x]==='land'){
            if(typ[y-1][x]!=='land' || typ[y+1][x]!=='land' || typ[y][x-1]!=='land' || typ[y][x+1]!=='land'){
              typ[y][x]='coast';
            }
          }
        }
      }

      const html = this.paint(buf, typ);
      this.host.innerHTML = html;
    }

    paint(buf, typ){
      const P=this.pal;
      const W=this.width,H=this.height;
      const cx=this.centerX, cy=this.centerY;
      const R=this.radius;

      const baseColor = (t)=>{
        if(t==='coast') return P.colCoast;
        if(t==='land') return P.colFillA;
        if(t==='ocean') return P.colOcean;
        return "#000000";
      };

      const over = Array.from({length:H},()=>Array(W).fill(null));

      // 2AM line
      if(this.show2AM){
        const am2Lon = get2AMLongitude();
        for(let y=0;y<H;y++){
          for(let x=0;x<W;x++){
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.hypot(dx, dy * this.cellAR);
            if(dist <= R){
              const sx = dx/R;
              const sy = -(dy * this.cellAR)/R;
              const z2 = 1 - sx*sx - sy*sy;
              if(z2 >= 0){
                const sz = Math.sqrt(z2);
                const lon = normLon(Math.atan2(sx, sz)*180/Math.PI + this.longitude);
                if(Math.abs(normLon(lon - am2Lon)) < 3){
                  over[y][x]={ch:'|', color:P.col2AM};
                }
              }
            }
          }
        }
      }

      let html='';
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const baseCh = buf[y][x];
          const baseT = typ[y][x];
          const overLay = over[y][x];
          let ch = baseCh;
          let color = baseColor(baseT);
          if(overLay){ ch = overLay.ch; color = overLay.color; }
          html += `<span style="color:${color}">${ch}</span>`;
        }
        if(y<H-1) html += '<br/>';
      }
      return html;
    }

    isPointOnLandEnhanced(lat, lon){
      let landCount=0;
      for(let dy=-1; dy<=1; dy+=2){
        for(let dx=-1; dx<=1; dx+=2){
          if(this.isPointOnLand(lat + dy*0.05, lon + dx*0.05)) landCount++;
        }
      }
      return landCount >= 2;
    }

    isPointOnLand(lat, lon){
      for(const points of Object.values(this.continents)){
        if(this.pointInPolygon(lat,lon,points)) return true;
      }
      return false;
    }

    pointInPolygon(lat, lon, poly){
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const [lat1,lon1]=poly[i], [lat2,lon2]=poly[j];
        if(((lat1>lat)!==(lat2>lat)) && (lon < (lon2-lon1)*(lat-lat1)/(lat2-lat1) + lon1)){
          inside=!inside;
        }
      }
      return inside;
    }

    lumToChar(L){
      const idx = Math.floor(Math.max(0,Math.min(1,L))*(this.luminanceRamp.length-1));
      return this.luminanceRamp[idx];
    }
  }

  const globe = new RandomGlobe();

  // --- Streams by GMT offset ---
  const radioStreams = {
    "-12": "https://worldwidefm.out.airtime.pro/worldwidefm_b",
    "-11": "https://worldwidefm.out.airtime.pro/worldwidefm_b",
    "-10": "https://orbit.citrus3.com:2020/stream/divineradiolondon",
    "-9": "https://stream.ktuh.org:8001/stream",
    "-8": "https://s26.myradiostream.com:17824/;?type=http&nocache=1742989445?0.10626689329334882/",
    "-7": "https://dublab.out.airtime.pro/dublab_a",
    "-6": "https://radio.mensajito.mx/nopalVentana",
    "-5": "https://edge.mixlr.com/channel/ibrdq",
    "-4": "https://n10as.radiocult.fm/stream",
    "-3": "https://servidor24-1.brlogic.com:7516/live",
    "-2": "http://ice-11.spilarinn.is/fmxtra",
    "-1": "https://stream.radioquantica.com:8443/stream",
    "0": "https://oroko-radio.radiocult.fm/stream",
    "1": "https://s107.radiolize.com:8000/radio.mp3",
    "2": "https://cashmereradio.out.airtime.pro/cashmereradio_b",
    "3": "https://20ft-radio.radiocult.fm/stream",
    "4": "https://n09.radiojar.com/78cxy6wkxtzuv?1742491576=&rj-ttl=5&rj-tok=AAABlmp-uzoAGwSgsdWpww34qA",
    "5": "https://www.muso.fm/api/proxy-stream?url=http%3A%2F%2F94.130.113.214%3A8000%2Fdubtechno",
    "6": "https://www.muso.fm/api/proxy-stream?url=http%3A%2F%2F94.130.113.214%3A8000%2Fschizoid",
    "7": "https://stream.zeno.fm/2uhuu5hvzqzuv",
    "8": "https://listen.belowground.fm/listen/belowground_fm/radio.mp3",
    "9": "https://uk5.internet-radio.com/proxy/mmr?mp=/stream",
    "10": "https://radio.beshknow.com/beshknow",
    "11": "https://stream.tbc.radio:8000/radio.mp3",
    "12": "https://radio.kamchatkalive.ru:8103/dance"
  };

  const streamLocations = {
    "-12": "Deadzone",
    "-11": "Deadzone",
    "-10": "Deep Sea",
    "-9": "Honolulu",
    "-8": "Alaska",
    "-7": "Los Angeles",
    "-6": "Mexico City",
    "-5": "Kingston",
    "-4": "Montreal",
    "-3": "Brasilia",
    "-2": "Rejkavik",
    "-1": "Capo Verde",
    "0": "Ghana",
    "1": "Dublin",
    "2": "Berlin",
    "3": "Kyiv",
    "4": "Bethlehem",
    "5": "Karachi",
    "6": "Goa",
    "7": "Jakkarta",
    "8": "Chengdu",
    "9": "Tokyo",
    "10": "Melbourne",
    "11": "Auckland",
    "12": "Kamchatka"
  };

    // Pick the stream for where it's currently 02:00 local time (nearest GMT offset)
    function pick2amStream() {
      const now = new Date();
      const utc = now.getUTCHours() + now.getUTCMinutes()/60;
      let offset = 2 - utc; // hours difference from UTC where it's 2AM
      while (offset < -12) offset += 24;
      while (offset > 12)  offset -= 24;

      const keys = Object.keys(radioStreams).map(Number);
      let bestKey = keys[0], bestDiff = Infinity;
      for (const k of keys) {
        const diff = Math.abs(offset - k);
        if (diff < bestDiff) { bestDiff = diff; bestKey = k; }
      }
      return { key: String(bestKey), stream: radioStreams[String(bestKey)] };
    }

    // Play the selected stream on first click on the globe
    const chosen = pick2amStream();
    const chosenStream = chosen.stream;
    document.getElementById("currentLocation").textContent = "now: " + streamLocations[chosen.key];
    const bgAudio = new Audio();
    bgAudio.preload = "none";
    document.getElementById("stage").addEventListener("click", () => {
      bgAudio.src = chosenStream;
      bgAudio.play().catch(()=>{});
    });
  </script>
</body>
</html>